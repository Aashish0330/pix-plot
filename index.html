<!DOCTYPE html>
<html>
  <head>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,600' rel='stylesheet'>
    <link rel='stylesheet' type='text/css' href='assets/css/style.css'>
    <title>Visualizing Image Fields</title>
    <meta name='author' content='Douglas Duhaime'>
  </head>
  <body>
    <script type='x-shader/x-vertex' id='vertex-shader'>
    /**
    * The vertex shader's main() function must define `gl_Position`,
    * which describes the position of each vertex in screen coordinates.
    *
    * To do so, we can use the following variables defined by Three.js:
    *   attribute vec3 position - stores each vertex's position in world space
    *   attribute vec2 uv - sets each vertex's the texture coordinates
    *   uniform mat4 projectionMatrix - maps camera space into screen space
    *   uniform mat4 modelViewMatrix - combines:
    *     model matrix: maps a point's local coordinate space into world space
    *     view matrix: maps world space into camera space
    *
    * `attributes` can vary from vertex to vertex and are defined as arrays
    *   with length equal to the number of vertices. Each index in the array
    *   is an attribute for the corresponding vertex. Each attribute must
    *   contain n_vertices * n_components, where n_components is the length
    *   of the given datatype (e.g. for a vec2, n_components = 2; for a float,
    *   n_components = 1)
    * `uniforms` are constant across all vertices
    * `varyings` are values passed from the vertex to the fragment shader
    *
    * For the full list of uniforms defined by three, see:
    *   https://threejs.org/docs/#api/renderers/webgl/WebGLProgram
    **/

    // set float precision
    precision highp float;

    // specify geometry and camera uniforms
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform vec3 cameraPosition;

    // instance attributes
    attribute vec3 position; // base x y z position for all points
    attribute vec3 translation; // x y z position offsets for an instance
    attribute float textureIndex; // index of an instance's texture
    attribute vec2 textureOffset; // offset of the texture coords for an instance

    // varyings: pass the uv coordinates of each vertex to the fragment shader
    varying float vTextureIndex; // pass the texture idx (varyings can't be bool or int)
    varying vec2 vTextureOffset; // pass the texture offset

    // function that returns the size of a point, scaled by the camera position
    float scalePoint(in vec3 pos, in vec3 cameraPosition) {
      float xDelta = pow(pos[0] - cameraPosition[0], 2.0);
      float yDelta = pow(pos[1] - cameraPosition[1], 2.0);
      float zDelta = pow(pos[2] - cameraPosition[2], 2.0);
      float delta  = pow(xDelta + yDelta + zDelta, 0.5);
      float size = 10000.0 / delta;
      return size;
    }

    void main() {
      // pass varyings to fragment shader
      vTextureIndex = textureIndex;
      vTextureOffset = textureOffset;

      // set point position
      vec3 pos = position + translation;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);

      // use the unscaled point position and camera position to set point size
      gl_PointSize = scalePoint(pos, cameraPosition);
    }
    </script>

    <script type='x-shader/x-fragment' id='fragment-shader'>
    /**
    * The fragment shader's main() function must define `gl_FragColor`,
    * which describes the pixel color of each pixel on the screen.
    *
    * To do so, we can use uniforms passed into the shader and varyings
    * passed from the vertex shader.
    *
    * Attempting to read a varying not generated by the vertex shader will
    * throw a warning but won't prevent shader compiling.
    **/

    precision highp float;

    // cellSize identifies the [w, h] size of each image in an atlas
    uniform vec2 cellSize;

    // textures contains an array of textures with length n textures
    uniform sampler2D textures[N_TEXTURES];

    // identify the uv values as a varying attribute
    varying vec2 vTextureOffset; // instance uv offsets
    varying float vTextureIndex; // set index of each object's texture

    void main() {
      int textureIndex = int(vTextureIndex);

      // 1.0 - gl_PointCoord.y flips each pixel so the image is rightside-up
      vec2 uv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );
      vec2 scaledUv = uv * cellSize;

      // The block below will be replaced with a tree of texture lookups
      TEXTURE_LOOKUP_TREE
    }
    </script>

    <header class='header'>
      <img class='logo' src='assets/images/dhlab-logo.svg' alt='DHLab logo' />
      <div class='app-name'>PixPlot</div>
      <div class='tagline'>Image fields in a Local Collection</div>
    </header>
    <div class='loader-scene'>
      <p class='welcome'>This page visualizes a large image collection within an interactive WebGL scene. Each image was processed with an <a href='https://www.cs.unc.edu/~wliu/papers/GoogLeNet.pdf' target='_blank'>Inception</a> Convolutional Neural Network, trained on <a href='http://image-net.org/challenges/LSVRC/2012/' target='_blank'>ImageNet 2012</a>, and projected into a two-dimensional manifold with the <a href='https://github.com/lmcinnes/umap' target='_blank'>UMAP</a> algorithm such that similar images appear proximate to one another.</p>
      <div class='loader-container'>
        <div class='loader-icon'>
          <div class='blocks'>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
            <div class='block'></div>
          </div>
        </div>
        <div id='progress'>0%</div>
      </div>
      <button id='enter'>Enter</button>
    </div>
    <nav>
      <div class='nav-inner'>
        <h2>Hotspots</h2>
        <div id='hotspots'></div>
        <script type='text/html' id='template'>
          <% _.forEach(hotspots, function(hotspot) { %>
            <div class='hotspot'>
              <div class='background-image'
                style='background-image: url("output/thumbs/128px/<%= hotspot.img %>")'></div>
              <div><%= hotspot.label %></div>
            </div>
          <% }); %>
        </script>
      </div>
    </nav>
    <div id='webgl-not-available'>
      <span class='browser-message'>Sorry, your browser is not able to load a WebGL scene currently. Please check your browser settings and try again.</span>
    </div>
    <noscript>
      <span class='browser-message'>Sorry, your browser is not able to load a WebGL scene currently. Please enable JavaScript and try again.</span>
    </noscript>
    <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js'></script>
    <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js'></script>
    <script type='text/javascript' src='assets/js/image-progress.js'></script>
    <script type='text/javascript' src='assets/js/object-assign-polyfill.js'></script>
    <script type='text/javascript' src='assets/vendor/tween.js'></script>
    <script type='text/javascript' src='assets/vendor/trackball-controls.js'></script>
    <script type='text/javascript' src='assets/vendor/texture-loader.js'></script>
    <script type='text/javascript' src='assets/vendor/stats.js'></script>
    <script type='text/javascript' src='assets/js/tsne-webgl.js'></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-101732875-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>